<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SerenBot Avanzado</title>
    <style>
        :root {
            --primary: #4e7ae6;
            --secondary: #7c4dff;
            --background: #f8f9fa;
            --surface: #ffffff;
            --on-surface: #212121;
            --on-primary: #ffffff;
            --success: #4caf50;
            --warning: #ff9800;
            --error: #f44336;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--background);
            color: var(--on-surface);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .chat-container {
            width: 100%;
            max-width: 800px;
            height: 90vh;
            background-color: var(--surface);
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .chat-header {
            padding: 20px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--on-primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .chat-header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .message {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            line-height: 1.5;
            position: relative;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-message {
            align-self: flex-end;
            background-color: var(--primary);
            color: var(--on-primary);
            border-bottom-right-radius: 4px;
        }
        
        .bot-message {
            align-self: flex-start;
            background-color: #eef2f8;
            color: var(--on-surface);
            border-bottom-left-radius: 4px;
        }
        
        .chat-input {
            padding: 16px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            display: flex;
            gap: 12px;
        }
        
        .chat-input input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 24px;
            outline: none;
            font-size: 1rem;
            transition: border-color 0.3s;
        }
        
        .chat-input input:focus {
            border-color: var(--primary);
        }
        
        .chat-input button {
            padding: 12px 20px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 24px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        
        .chat-input button:hover {
            background-color: #3b5fc0;
        }
        
        .quick-suggestions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 0 16px 16px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
        }
        
        .suggestion-chip {
            padding: 8px 16px;
            background-color: #eef2f8;
            border-radius: 16px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .suggestion-chip:hover {
            background-color: #dfe6f3;
        }
        
        .typing-indicator {
            align-self: flex-start;
            background-color: #eef2f8;
            padding: 12px 16px;
            border-radius: 18px;
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            background-color: #9e9e9e;
            border-radius: 50%;
            animation: typingAnimation 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(1) { animation-delay: 0s; }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typingAnimation {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-5px); }
        }
        
        .message-time {
            font-size: 0.7rem;
            margin-top: 4px;
            opacity: 0.7;
        }

        .notification-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--surface);
            color: var(--on-surface);
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
            z-index: 1000;
        }

        .notification-toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        @media (max-width: 600px) {
            .chat-container {
                height: 95vh;
                border-radius: 12px;
            }
            
            .message {
                max-width: 90%;
            }
            
            .chat-header h1 {
                font-size: 1.3rem;
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1 id="chatTitle">SerenBot</h1>
            <select id="languageSelector" aria-label="Selector de idioma" style="margin-left: auto; padding: 8px; border-radius: 8px; border: none; background: rgba(255,255,255,0.2); color: white; cursor: pointer;">
                <option value="es">Español</option>
                <option value="en">English</option>
            </select>
        </div>
        <div class="chat-messages" id="chatMessages">
            <div class="message bot-message">
                <span id="initialMessage">¡Hola! Soy SerenBot, tu asistente virtual en Serenamente. Estoy aquí para ayudarte con tu bienestar emocional. ¿Cómo te sientes hoy?</span>
                <div class="message-time">Ahora</div>
            </div>
        </div>
        <div class="quick-suggestions" id="quickSuggestions">
            <div class="suggestion-chip">Técnicas para ansiedad</div>
            <div class="suggestion-chip">Cómo dormir mejor</div>
            <div class="suggestion-chip">Ejercicio de respiración</div>
            <div class="suggestion-chip">Registrar mis emociones</div>
        </div>
        <div class="chat-input">
            <input type="text" id="userInput" placeholder="Escribe tu mensaje aquí..." autocomplete="off" aria-label="Escribe tu mensaje">
            <button id="sendButton" aria-label="Enviar mensaje">Enviar</button>
        </div>
    </div>

    <div class="notification-toast" id="notificationToast"></div>

    <script>
        // Gestor de internacionalización (i18n)
        class I18nManager {
            constructor() {
                this.currentLanguage = 'es';
                this.translations = {};
                this.fallbackLanguage = 'es';
            }
            
            async loadLanguage(language) {
                try {
                    if (!this.translations[language]) {
                        const response = await fetch(`./i18n/${language}.json`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        this.translations[language] = await response.json();
                    }
                    this.currentLanguage = language;
                    return true;
                } catch (error) {
                    console.error(`Error loading language ${language}:`, error);
                    // Fallback al idioma por defecto si no está cargado
                    if (language !== this.fallbackLanguage && !this.translations[this.fallbackLanguage]) {
                        try {
                            const fallbackResponse = await fetch(`./i18n/${this.fallbackLanguage}.json`);
                            this.translations[this.fallbackLanguage] = await fallbackResponse.json();
                            this.currentLanguage = this.fallbackLanguage;
                        } catch (fallbackError) {
                            console.error('Failed to load fallback language:', fallbackError);
                        }
                    }
                    return false;
                }
            }
            
            translate(key, replacements = {}) {
                try {
                    const keys = key.split('.');
                    let value = this.translations[this.currentLanguage];
                    
                    for (const k of keys) {
                        if (value && typeof value === 'object' && k in value) {
                            value = value[k];
                        } else {
                            // Intentar con idioma de respaldo
                            value = this.translations[this.fallbackLanguage];
                            for (const fallbackK of keys) {
                                if (value && typeof value === 'object' && fallbackK in value) {
                                    value = value[fallbackK];
                                } else {
                                    return key; // Retornar la clave si no se encuentra
                                }
                            }
                            break;
                        }
                    }
                    
                    if (typeof value === 'string') {
                        // Aplicar reemplazos
                        let result = value;
                        for (const [placeholder, replacement] of Object.entries(replacements)) {
                            const regex = new RegExp(`\\{${placeholder}\\}`, 'g');
                            result = result.replace(regex, replacement || '');
                        }
                        return result;
                    }
                    
                    return value;
                } catch (error) {
                    console.error('Error translating key:', key, error);
                    return key;
                }
            }
            
            getCurrentLanguage() {
                return this.currentLanguage;
            }
            
            getAvailableLanguages() {
                return Object.keys(this.translations);
            }
            
            // Método para obtener respuestas aleatorias de arrays
            getRandomTranslation(key, replacements = {}) {
                const value = this.translate(key, replacements);
                if (Array.isArray(value)) {
                    return value[Math.floor(Math.random() * value.length)];
                }
                return value;
            }
        }

        // Clase de utilidades para localStorage
        class StorageManager {
            static save(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e) {
                    console.error('Error guardando en localStorage:', e);
                    return false;
                }
            }
            
            static load(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (e) {
                    console.error('Error cargando desde localStorage:', e);
                    return null;
                }
            }
            
            static clear(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch (e) {
                    console.error('Error limpiando localStorage:', e);
                    return false;
                }
            }
        }

        // Gestor de notificaciones
        class NotificationManager {
            constructor() {
                this.toast = document.getElementById('notificationToast');
                this.notificationPermission = false;
                
                // Solicitar permiso para notificaciones
                if ('Notification' in window) {
                    Notification.requestPermission().then(permission => {
                        this.notificationPermission = permission === 'granted';
                    });
                }
            }
            
            showNotification(title, options = {}) {
                // Notificación del navegador
                if (this.notificationPermission) {
                    const notification = new Notification(title, {
                        icon: '/favicon.ico',
                        badge: '/favicon.ico',
                        ...options
                    });
                    
                    notification.onclick = () => {
                        window.focus();
                        notification.close();
                    };
                    
                    return notification;
                }
                
                // Toast como fallback
                this.showToast(title);
                return null;
            }
            
            showToast(message, duration = 3000) {
                this.toast.textContent = message;
                this.toast.classList.add('show');
                
                setTimeout(() => {
                    this.toast.classList.remove('show');
                }, duration);
            }
        }

        // Gestor de errores mejorado
        class ErrorHandler {
            static handle(error, context = '', userFriendly = true) {
                console.error(`Error en ${context}:`, error);
                
                // Análisis del tipo de error para respuestas más específicas
                let errorType = 'general_error';
                if (error.name === 'TypeError' || error.name === 'ReferenceError') {
                    errorType = 'processing_error';
                } else if (error.message && error.message.includes('fetch')) {
                    errorType = 'network_error';
                } else if (error.message && error.message.includes('localStorage')) {
                    errorType = 'storage_error';
                }
                
                // En un entorno real, enviaríamos este error a un servicio de tracking
                // Aquí lo registramos de forma anónima
                const errorReport = {
                    timestamp: new Date().toISOString(),
                    context: context,
                    type: error.name || 'UnknownError',
                    message: this.sanitizeErrorMessage(error.message),
                    userAgent: navigator.userAgent.substring(0, 100), // Información limitada
                    url: window.location.pathname
                };
                
                // Guardar en localStorage para análisis posterior (sin datos sensibles)
                try {
                    const errorLogs = JSON.parse(localStorage.getItem('serenbot_error_logs') || '[]');
                    errorLogs.push(errorReport);
                    // Mantener solo los últimos 10 errores
                    if (errorLogs.length > 10) {
                        errorLogs.splice(0, errorLogs.length - 10);
                    }
                    localStorage.setItem('serenbot_error_logs', JSON.stringify(errorLogs));
                } catch (logError) {
                    console.warn('Cannot log error to storage:', logError);
                }
                
                if (userFriendly && window.i18nManager) {
                    return window.i18nManager.translate(`errors.${errorType}`);
                }
                
                return 'Lo siento, ha ocurrido un error procesando tu solicitud. Por favor, inténtalo de nuevo.';
            }
            
            static sanitizeErrorMessage(message) {
                if (!message) return 'Unknown error';
                
                // Remover información potencialmente sensible
                return message
                    .replace(/\b[\w\.-]+@[\w\.-]+\.\w+\b/g, '[email]') // Emails
                    .replace(/\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g, '[card]') // Números de tarjeta
                    .replace(/\b\d{3}-\d{2}-\d{4}\b/g, '[ssn]') // SSN
                    .substring(0, 200); // Limitar longitud
            }
            
            static getErrorLogs() {
                try {
                    return JSON.parse(localStorage.getItem('serenbot_error_logs') || '[]');
                } catch (error) {
                    console.error('Error retrieving error logs:', error);
                    return [];
                }
            }
            
            static clearErrorLogs() {
                try {
                    localStorage.removeItem('serenbot_error_logs');
                    return true;
                } catch (error) {
                    console.error('Error clearing error logs:', error);
                    return false;
                }
            }
        }

        // Gestor de seguridad y anonimización
        class SecurityManager {
            static sanitizeInput(input) {
                if (typeof input !== 'string') return input;
                
                // Sanitizar HTML y caracteres peligrosos
                const sanitized = input
                    .replace(/[<>]/g, '') // Remover < y >
                    .replace(/javascript:/gi, '') // Remover javascript:
                    .replace(/on\w+=/gi, '') // Remover eventos HTML
                    .trim();
                
                // Limitar longitud del input
                return sanitized.substring(0, 1000);
            }
            
            static anonymizeData(data) {
                if (typeof data !== 'object' || data === null) return data;
                
                const anonymized = JSON.parse(JSON.stringify(data));
                
                // Buscar y anonimizar patrones comunes de datos sensibles
                const sensitivePatterns = {
                    email: /\b[\w\.-]+@[\w\.-]+\.\w+\b/g,
                    phone: /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g,
                    card: /\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g,
                    ssn: /\b\d{3}-\d{2}-\d{4}\b/g
                };
                
                function anonymizeObject(obj) {
                    for (const [key, value] of Object.entries(obj)) {
                        if (typeof value === 'string') {
                            let newValue = value;
                            for (const [pattern, regex] of Object.entries(sensitivePatterns)) {
                                newValue = newValue.replace(regex, `[${pattern}]`);
                            }
                            obj[key] = newValue;
                        } else if (typeof value === 'object' && value !== null) {
                            anonymizeObject(value);
                        }
                    }
                }
                
                anonymizeObject(anonymized);
                return anonymized;
            }
            
            static hashData(data) {
                // Función simple de hash para identificadores únicos sin exponer datos
                let hash = 0;
                const str = JSON.stringify(data);
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convertir a 32bit integer
                }
                return Math.abs(hash).toString(36);
            }
            
            static encryptData(data, key) {
                // Implementación básica de ofuscación (en producción usar crypto APIs)
                try {
                    const jsonString = JSON.stringify(data);
                    let encrypted = '';
                    for (let i = 0; i < jsonString.length; i++) {
                        encrypted += String.fromCharCode(
                            jsonString.charCodeAt(i) ^ key.charCodeAt(i % key.length)
                        );
                    }
                    return btoa(encrypted);
                } catch (error) {
                    console.error('Encryption error:', error);
                    return null;
                }
            }
            
            static decryptData(encryptedData, key) {
                // Implementación básica de desofuscación
                try {
                    const encrypted = atob(encryptedData);
                    let decrypted = '';
                    for (let i = 0; i < encrypted.length; i++) {
                        decrypted += String.fromCharCode(
                            encrypted.charCodeAt(i) ^ key.charCodeAt(i % key.length)
                        );
                    }
                    return JSON.parse(decrypted);
                } catch (error) {
                    console.error('Decryption error:', error);
                    return null;
                }
            }
        }

        // SerenBot mejorado con algoritmos avanzados
        class EnhancedSerenBot {
            constructor() {
                this.isOpen = true;
                this.messages = [];
                this.currentContext = 'general';
                this.waitingForInput = false;
                this.userName = null;
                this.userMood = null;
                this.lastInteraction = null;
                this.conversationHistory = [];
                this.userPreferences = {
                    language: 'es',
                    moodReminders: false,
                    mindfulnessReminders: false,
                    dataEncryption: false
                };
                this.emotionalState = {
                    mood: null,
                    intensity: 1,
                    triggers: [],
                    patterns: []
                };
                
                // Inicializar managers
                this.storageManager = StorageManager;
                this.notificationManager = new NotificationManager();
                this.i18nManager = new I18nManager();
                window.i18nManager = this.i18nManager; // Hacer disponible globalmente
                
                // Clave de cifrado para datos sensibles (en producción vendría del servidor)
                this.encryptionKey = 'serenbot_' + (navigator.userAgent + Date.now()).substring(0, 16);
                
                // Cargar datos guardados
                this.loadUserData();
                
                // Configurar recordatorios
                this.setupReminders();
                
                // Inicializar sistema de idiomas
                this.initializeI18n();
                
                // Modelo de clasificación de intenciones mejorado
                this.intentModel = {
                    vocabulary: new Set(),
                    intents: {},
                    train: function(examples) {
                        examples.forEach((exampleArray, intent) => {
                            if (!this.intents[intent]) this.intents[intent] = { count: 0, words: {} };
                            
                            exampleArray.forEach(example => {
                                const words = example.toLowerCase().split(/\s+/);
                                words.forEach(word => {
                                    this.vocabulary.add(word);
                                    this.intents[intent].words[word] = (this.intents[intent].words[word] || 0) + 1;
                                });
                                
                                this.intents[intent].count++;
                            });
                        });
                    },
                    predict: function(text) {
                        try {
                            const words = text.toLowerCase().split(/\s+/);
                            let bestIntent = null;
                            let bestScore = 0;
                            
                            for (const intent in this.intents) {
                                let score = 0;
                                words.forEach(word => {
                                    if (this.intents[intent].words[word]) {
                                        score += this.intents[intent].words[word];
                                    }
                                });
                                
                                // Normalizar por longitud del texto e importancia de la intención
                                score = score / words.length / this.intents[intent].count;
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestIntent = intent;
                                }
                            }
                            
                            return bestScore > 0.3 ? bestIntent : 'unknown';
                        } catch (error) {
                            ErrorHandler.handle(error, 'predict intent');
                            return 'unknown';
                        }
                    }
                };
                
                // Entrenar el modelo con ejemplos
                this.trainIntentModel();
                
                // Mapeo de intenciones a claves de traducción
                this.intentToI18nMapping = {
                    saludos: 'greetings',
                    ayuda: 'help',
                    tecnicas: 'techniques',
                    emociones: 'emotions',
                    respiracion: 'breathing',
                    sueno: 'sleep',
                    crisis: 'crisis',
                    despedida: 'farewell'
                };
                
                // Sugerencias contextuales (se cargarán desde i18n)
                this.quickSuggestions = [];
            }
            
            // Método para inicializar el sistema i18n
            async initializeI18n() {
                try {
                    // Cargar idioma guardado o usar el por defecto
                    const savedLanguage = this.userPreferences.language || 'es';
                    await this.i18nManager.loadLanguage(savedLanguage);
                    
                    // Actualizar la interfaz con el idioma cargado
                    this.updateUI();
                    
                    console.log(`Language ${savedLanguage} loaded successfully`);
                } catch (error) {
                    ErrorHandler.handle(error, 'initializing i18n');
                }
            }
            
            // Método para cambiar idioma
            async changeLanguage(language) {
                try {
                    const success = await this.i18nManager.loadLanguage(language);
                    if (success) {
                        this.userPreferences.language = language;
                        this.updateUI();
                        this.saveUserData();
                        
                        // Notificar cambio exitoso
                        this.notificationManager.showToast(
                            this.i18nManager.translate('notifications.data_saved')
                        );
                        
                        return true;
                    }
                    return false;
                } catch (error) {
                    ErrorHandler.handle(error, 'changing language');
                    return false;
                }
            }
            
            // Método para actualizar la interfaz con las traducciones
            updateUI() {
                try {
                    // Actualizar elementos de la interfaz
                    const elements = {
                        'chatTitle': 'ui.title',
                        'userInput': 'ui.input_placeholder',
                        'sendButton': 'ui.send_button',
                        'initialMessage': 'greetings.initial_message'
                    };
                    
                    for (const [elementId, translationKey] of Object.entries(elements)) {
                        const element = document.getElementById(elementId);
                        if (element) {
                            if (elementId === 'userInput') {
                                element.placeholder = this.i18nManager.translate(translationKey);
                                element.setAttribute('aria-label', this.i18nManager.translate('ui.input_aria'));
                            } else if (elementId === 'sendButton') {
                                element.textContent = this.i18nManager.translate(translationKey);
                                element.setAttribute('aria-label', this.i18nManager.translate('ui.send_button_aria'));
                            } else {
                                element.textContent = this.i18nManager.translate(translationKey);
                            }
                        }
                    }
                    
                    // Actualizar selector de idioma
                    const languageSelector = document.getElementById('languageSelector');
                    if (languageSelector) {
                        languageSelector.value = this.i18nManager.getCurrentLanguage();
                        languageSelector.setAttribute('aria-label', this.i18nManager.translate('ui.language_selector_aria'));
                    }
                    
                    // Actualizar sugerencias
                    this.updateQuickSuggestions();
                } catch (error) {
                    ErrorHandler.handle(error, 'updating UI');
                }
            }
            
            // Cargar datos del usuario desde localStorage con seguridad mejorada
            loadUserData() {
                try {
                    const userData = this.storageManager.load('serenbot_user_data');
                    if (userData) {
                        // Verificar si los datos están cifrados
                        if (userData.encrypted) {
                            const decryptedData = SecurityManager.decryptData(userData.data, this.encryptionKey);
                            if (decryptedData) {
                                this.populateUserData(decryptedData);
                            } else {
                                console.warn('Failed to decrypt user data, using defaults');
                                this.setDefaultUserData();
                            }
                        } else {
                            this.populateUserData(userData);
                        }
                        
                        console.log('Datos de usuario cargados correctamente');
                    } else {
                        this.setDefaultUserData();
                    }
                } catch (error) {
                    ErrorHandler.handle(error, 'loading user data');
                    this.setDefaultUserData();
                }
            }
            
            // Método auxiliar para establecer datos por defecto
            setDefaultUserData() {
                this.userPreferences = {
                    language: 'es',
                    moodReminders: false,
                    mindfulnessReminders: false,
                    dataEncryption: false
                };
                this.emotionalState = {
                    mood: null,
                    intensity: 1,
                    triggers: [],
                    patterns: []
                };
                this.conversationHistory = [];
            }
            
            // Método auxiliar para poblar datos de usuario
            populateUserData(userData) {
                this.userName = userData.userName;
                this.userMood = userData.userMood;
                this.conversationHistory = userData.conversationHistory || [];
                this.userPreferences = {
                    language: userData.userPreferences?.language || 'es',
                    moodReminders: userData.userPreferences?.moodReminders || false,
                    mindfulnessReminders: userData.userPreferences?.mindfulnessReminders || false,
                    dataEncryption: userData.userPreferences?.dataEncryption || false,
                    ...userData.userPreferences
                };
                this.emotionalState = userData.emotionalState || {
                    mood: null,
                    intensity: 1,
                    triggers: [],
                    patterns: []
                };
            }
            
            // Guardar datos del usuario en localStorage con seguridad mejorada
            saveUserData() {
                try {
                    let userData = {
                        userName: this.userName,
                        userMood: this.userMood,
                        conversationHistory: this.conversationHistory.slice(-30), // Mantener solo los últimos 30 mensajes
                        userPreferences: this.userPreferences,
                        emotionalState: this.emotionalState,
                        lastSave: new Date().toISOString()
                    };
                    
                    // Anonimizar datos antes de guardar
                    userData = SecurityManager.anonymizeData(userData);
                    
                    // Cifrar datos si está habilitado
                    if (this.userPreferences.dataEncryption) {
                        const encryptedData = SecurityManager.encryptData(userData, this.encryptionKey);
                        if (encryptedData) {
                            userData = {
                                encrypted: true,
                                data: encryptedData,
                                timestamp: new Date().toISOString()
                            };
                        }
                    }
                    
                    const success = this.storageManager.save('serenbot_user_data', userData);
                    if (success) {
                        console.log('Datos de usuario guardados correctamente');
                        
                        // Notificar éxito si hay notificationManager disponible
                        if (this.i18nManager && this.notificationManager) {
                            const message = this.i18nManager.translate('notifications.data_saved');
                            if (message && message !== 'notifications.data_saved') {
                                // Solo mostrar si la traducción está disponible
                                // this.notificationManager.showToast(message);
                            }
                        }
                    } else {
                        console.error('Error guardando datos de usuario');
                        if (this.i18nManager && this.notificationManager) {
                            const message = this.i18nManager.translate('errors.storage_error');
                            if (message && message !== 'errors.storage_error') {
                                this.notificationManager.showToast(message);
                            }
                        }
                    }
                } catch (error) {
                    ErrorHandler.handle(error, 'saving user data');
                }
            }
            
            // Configurar recordatorios basados en preferencias
            setupReminders() {
                // Limpiar recordatorios anteriores
                if (this.reminderIntervals) {
                    this.reminderIntervals.forEach(interval => clearInterval(interval));
                }
                
                this.reminderIntervals = [];
                
                // Recordatorio para registro del estado de ánimo (si está activo en preferencias)
                if (this.userPreferences.moodReminders) {
                    const moodInterval = setInterval(() => {
                        const now = new Date();
                        // Solo enviar recordatorio entre las 8 AM y las 8 PM
                        if (now.getHours() >= 8 && now.getHours() < 20) {
                            const lastMoodRecord = this.userPreferences.lastMoodRecord;
                            const shouldRemind = !lastMoodRecord || 
                                              (new Date() - new Date(lastMoodRecord)) > 12 * 60 * 60 * 1000; // 12 horas
                            
                            if (shouldRemind) {
                                this.notificationManager.showNotification(
                                    'Serenamente', 
                                    {
                                        body: '¿Cómo te sientes hoy? Es un buen momento para registrar tu estado de ánimo.',
                                        icon: '/favicon.ico'
                                    }
                                );
                            }
                        }
                    }, 60 * 60 * 1000); // Revisar cada hora
                    
                    this.reminderIntervals.push(moodInterval);
                }
                
                // Recordatorio para prácticas de mindfulness (si está activo en preferencias)
                if (this.userPreferences.mindfulnessReminders) {
                    const mindfulnessInterval = setInterval(() => {
                        const now = new Date();
                        // Horarios sugeridos: 9 AM, 1 PM, 6 PM
                        const reminderTimes = [9, 13, 18];
                        if (reminderTimes.includes(now.getHours()) && now.getMinutes() === 0) {
                            this.notificationManager.showNotification(
                                'Serenamente', 
                                {
                                    body: 'Momento de mindfulness. ¿Te gustaría hacer un breve ejercicio de respiración?',
                                    icon: '/favicon.ico'
                                }
                            );
                        }
                    }, 60 * 1000); // Revisar cada minuto
                    
                    this.reminderIntervals.push(mindfulnessInterval);
                }
            }
            
            trainIntentModel() {
                try {
                    // Ejemplos de entrenamiento para el modelo de clasificación de intenciones
                    const trainingExamples = new Map();
                    
                    trainingExamples.set('saludos', ['hola', 'hola cómo estás', 'buenos días', 'buenas tardes', 'hey']);
                    trainingExamples.set('ayuda', ['necesito ayuda', 'qué puedes hacer', 'ayúdame', 'no sé usar la app']);
                    trainingExamples.set('tecnicas', ['técnicas de relajación', 'ejercicios para calmarme', 'cómo manejar la ansiedad']);
                    trainingExamples.set('sueno', ['no puedo dormir', 'tengo insomnio', 'cómo dormir mejor']);
                    trainingExamples.set('emociones', ['me siento triste', 'estoy ansioso', 'cómo manejar el enojo']);
                    trainingExamples.set('crisis', ['me siento muy mal', 'necesito ayuda urgente', 'estoy en crisis']);
                    
                    this.intentModel.train(trainingExamples);
                } catch (error) {
                    ErrorHandler.handle(error, 'training intent model');
                }
            }
            
            async processMessage(message) {
                try {
                    // Sanitizar entrada para seguridad
                    const sanitizedMessage = SecurityManager.sanitizeInput(message);
                    
                    // Simular tiempo de procesamiento para una experiencia más natural
                    this.showTypingIndicator();
                    await this.delay(800 + Math.random() * 700);
                    
                    const normalizedMessage = sanitizedMessage.toLowerCase().trim();
                    this.addToConversationHistory('user', sanitizedMessage);
                    
                    // Análisis de sentimiento mejorado
                    const sentiment = this.analyzeSentiment(normalizedMessage);
                    this.updateEmotionalState(sentiment, normalizedMessage);
                    
                    // Detectar y almacenar el nombre del usuario
                    if (!this.userName && this.isNameIntroduction(normalizedMessage)) {
                        this.userName = this.extractName(normalizedMessage);
                        const response = this.i18nManager.getRandomTranslation(
                            'greetings.responses', 
                            { name: this.userName ? ` ${this.userName}` : '' }
                        );
                        this.addToConversationHistory('bot', response);
                        this.hideTypingIndicator();
                        
                        // Guardar datos después de obtener el nombre
                        this.saveUserData();
                        return response;
                    }
                    
                    // Clasificar la intención usando el modelo
                    const intent = this.intentModel.predict(normalizedMessage);
                    
                    // Detectar estado de ánimo
                    const detectedMood = this.detectMood(normalizedMessage);
                    if (detectedMood && !this.waitingForInput) {
                        this.userMood = detectedMood;
                        this.userPreferences.lastMoodRecord = new Date().toISOString();
                        this.lastInteraction = 'mood_detection';
                        
                        // Usar i18n para respuestas empáticas
                        let response = this.i18nManager.translate(`emotions.empathy.${detectedMood}`);
                        if (response === `emotions.empathy.${detectedMood}`) {
                            // Fallback a respuesta general si no hay traducción específica
                            response = this.i18nManager.translate('emotions.empathy.general');
                        }
                        
                        this.waitingForInput = true;
                        this.addToConversationHistory('bot', response);
                        this.hideTypingIndicator();
                        
                        // Guardar datos después de detectar el estado de ánimo
                        this.saveUserData();
                        return response;
                    }
                    
                    // Manejar respuestas de seguimiento
                    if (this.waitingForInput) {
                        const response = this.handleFollowUp(normalizedMessage);
                        this.addToConversationHistory('bot', response);
                        this.hideTypingIndicator();
                        
                        // Guardar datos después de seguimiento
                        this.saveUserData();
                        return response;
                    }
                    
                    // Buscar respuesta basada en intención usando i18n
                    if (this.intentToI18nMapping[intent]) {
                        this.currentContext = intent;
                        const translationKey = this.intentToI18nMapping[intent];
                        
                        let response = this.i18nManager.getRandomTranslation(
                            `${translationKey}.responses`,
                            { name: this.userName ? ` ${this.userName}` : '' }
                        );
                        
                        // Agregar pregunta de seguimiento si existe
                        const followUp = this.i18nManager.translate(`${translationKey}.follow_up`);
                        if (followUp && followUp !== `${translationKey}.follow_up` && !this.waitingForInput) {
                            this.waitingForInput = true;
                            response = response + '\n\n' + followUp;
                        }
                        
                        this.addToConversationHistory('bot', response);
                        this.hideTypingIndicator();
                        
                        // Guardar datos después de procesar la intención
                        this.saveUserData();
                        return response;
                    }
                    
                    // Si no encuentra coincidencia, respuesta por defecto usando i18n
                    const defaultResponse = this.i18nManager.getRandomTranslation('default_responses');
                    const helpSuggestions = '\n\nPuedes preguntarme sobre:\n• Técnicas de relajación\n• Cómo manejar emociones difíciles\n• Estrategias para dormir mejor\n• Uso del diario emocional\n• Seguimiento de tu progreso';
                    const enhancedResponse = defaultResponse + helpSuggestions;
                    
                    this.addToConversationHistory('bot', enhancedResponse);
                    this.hideTypingIndicator();
                    
                    // Guardar datos después de respuesta por defecto
                    this.saveUserData();
                    return enhancedResponse;
                } catch (error) {
                    this.hideTypingIndicator();
                    return ErrorHandler.handle(error, 'processing message');
                }
            }
            
            analyzeSentiment(message) {
                try {
                    // Algoritmo mejorado de análisis de sentimiento
                    const positiveWords = ['bien', 'feliz', 'contento', 'genial', 'maravilloso', 'agradecido', 'optimista', 'alegre', 'emocionado'];
                    const negativeWords = ['mal', 'triste', 'ansioso', 'estresado', 'enojado', 'preocupado', 'asustado', 'nervioso', 'desbordado', 'agobiado', 'frustrado'];
                    const intenseWords = ['muy', 'mucho', 'extremadamente', 'realmente', 'totalmente', 'completamente'];
                    
                    const words = message.toLowerCase().split(/\s+/);
                    let score = 0;
                    let intensity = 1;
                    
                    words.forEach(word => {
                        if (positiveWords.includes(word)) score += 1;
                        if (negativeWords.includes(word)) score -= 1;
                        if (intenseWords.includes(word)) intensity += 0.5;
                    });
                    
                    return { score, intensity };
                } catch (error) {
                    ErrorHandler.handle(error, 'analyzing sentiment');
                    return { score: 0, intensity: 1 };
                }
            }
            
            updateEmotionalState(sentiment, message) {
                try {
                    // Actualizar el estado emocional basado en el análisis de sentimiento
                    if (sentiment.score > 0) {
                        this.emotionalState.mood = 'positive';
                    } else if (sentiment.score < 0) {
                        this.emotionalState.mood = 'negative';
                    } else {
                        this.emotionalState.mood = 'neutral';
                    }
                    
                    this.emotionalState.intensity = sentiment.intensity;
                    
                    // Extraer posibles desencadenantes emocionales
                    const triggerWords = ['porque', 'debido a', 'cuando', 'después de', 'por'];
                    const words = message.split(/\s+/);
                    
                    for (let i = 0; i < words.length; i++) {
                        if (triggerWords.includes(words[i]) && i < words.length - 1) {
                            this.emotionalState.triggers.push(words.slice(i + 1, i + 4).join(' '));
                        }
                    }
                    
                    // Limitar el historial de desencadenantes
                    if (this.emotionalState.triggers.length > 10) {
                        this.emotionalState.triggers = this.emotionalState.triggers.slice(-10);
                    }
                } catch (error) {
                    ErrorHandler.handle(error, 'updating emotional state');
                }
            }
            
            addToConversationHistory(role, message) {
                try {
                    this.conversationHistory.push({
                        role,
                        message,
                        timestamp: new Date(),
                        mood: this.emotionalState.mood,
                        intensity: this.emotionalState.intensity
                    });
                    
                    // Limitar el historial para no consumir demasiada memoria
                    if (this.conversationHistory.length > 50) {
                        this.conversationHistory = this.conversationHistory.slice(-50);
                    }
                } catch (error) {
                    ErrorHandler.handle(error, 'adding to conversation history');
                }
            }
            
            showTypingIndicator() {
                try {
                    const chatMessages = document.getElementById('chatMessages');
                    const typingIndicator = document.createElement('div');
                    typingIndicator.className = 'typing-indicator';
                    typingIndicator.id = 'typingIndicator';
                    typingIndicator.setAttribute('aria-label', 'El bot está escribiendo');
                    typingIndicator.innerHTML = `
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    `;
                    chatMessages.appendChild(typingIndicator);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                } catch (error) {
                    ErrorHandler.handle(error, 'showing typing indicator');
                }
            }
            
            hideTypingIndicator() {
                try {
                    const typingIndicator = document.getElementById('typingIndicator');
                    if (typingIndicator) {
                        typingIndicator.remove();
                    }
                } catch (error) {
                    ErrorHandler.handle(error, 'hiding typing indicator');
                }
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            isNameIntroduction(message) {
                try {
                    const namePatterns = [
                        /me llamo (\w+)/i,
                        /soy (\w+)/i,
                        /mi nombre es (\w+)/i,
                        /puedes llamarme (\w+)/i
                    ];
                    
                    return namePatterns.some(pattern => pattern.test(message));
                } catch (error) {
                    ErrorHandler.handle(error, 'checking name introduction');
                    return false;
                }
            }

            extractName(message) {
                try {
                    const patterns = [
                        /me llamo (\w+)/i,
                        /soy (\w+)/i,
                        /mi nombre es (\w+)/i,
                        /puedes llamarme (\w+)/i
                    ];
                    
                    for (const pattern of patterns) {
                        const match = message.match(pattern);
                        if (match) return match[1];
                    }
                    
                    return null;
                } catch (error) {
                    ErrorHandler.handle(error, 'extracting name');
                    return null;
                }
            }

            detectMood(message) {
                try {
                    const moodKeywords = {
                        triste: ['triste', 'deprimido', 'desanimado', 'desesperanzado', 'melancólico', 'apenado'],
                        ansioso: ['ansioso', 'nervioso', 'preocupado', 'agitado', 'intranquilo', 'atemorizado'],
                        estresado: ['estresado', 'agobiado', 'abrumado', 'presionado', 'tenso', 'frustrado'],
                        enojado: ['enojado', 'enfadado', 'furioso', 'molesto', 'irritado', 'airado'],
                        feliz: ['feliz', 'contento', 'alegre', 'optimista', 'entusiasmado', 'emocionado']
                    };
                    
                    for (const [mood, keywords] of Object.entries(moodKeywords)) {
                        if (keywords.some(keyword => message.includes(keyword))) {
                            return mood;
                        }
                    }
                    
                    return null;
                } catch (error) {
                    ErrorHandler.handle(error, 'detecting mood');
                    return null;
                }
            }

            handleFollowUp(message) {
                try {
                    this.waitingForInput = false;
                    
                    switch (this.currentContext) {
                        case 'emociones':
                            if (message.includes('sí') || message.includes('si') || message.includes('yes') || message.includes('por favor') || message.includes('please')) {
                                return this.i18nManager.getRandomTranslation('techniques.responses', {
                                    name: this.userName ? ` ${this.userName}` : ''
                                });
                            }
                            break;
                            
                        case 'respiracion':
                            if (message.includes('sí') || message.includes('si') || message.includes('yes') || message.includes('guiar') || message.includes('guide')) {
                                return this.i18nManager.translate('breathing.guided_exercise');
                            }
                            break;
                            
                        case 'sueno':
                            if (message.includes('conciliar') || message.includes('fall asleep')) {
                                return this.i18nManager.translate('sleep.responses.0') + '\n\n¿Te gustaría que te guíe con esta técnica ahora mismo?';
                            } else if (message.includes('mantener') || message.includes('stay asleep')) {
                                return `Para mantener el sueño:\n\n- Establece una rutina consistente de sueño\n- Evita alcohol y cafeína después de las 2 PM\n- Crea un ambiente óptimo para dormir (fresco, oscuro y silencioso)\n- Si te despiertas, evita mirar el reloj\n\n¿Te gustaría más consejos sobre higiene del sueño?`;
                            }
                            break;
                            
                        default:
                            return this.i18nManager.translate('default_responses.0') || 'Gracias por la información. ¿Hay algo más en lo que pueda ayudarte?';
                    }
                    
                    return this.i18nManager.translate('default_responses.0') || 'Entiendo. ¿Hay algo más en lo que pueda ayudarte?';
                } catch (error) {
                    ErrorHandler.handle(error, 'handling follow-up');
                    return 'Gracias por la información. ¿Hay algo más en lo que pueda ayudarte?';
                }
            }

            guidedBreathingExercise() {
                return this.i18nManager.translate('breathing.guided_exercise');
            }
            
            // Método para generar sugerencias contextuales basadas en la conversación usando i18n
            generateContextualSuggestions() {
                try {
                    if (this.conversationHistory.length < 2) {
                        return this.i18nManager.translate('suggestions.default') || [];
                    }
                    
                    const lastMessage = this.conversationHistory[this.conversationHistory.length - 1].message.toLowerCase();
                    
                    if (lastMessage.includes('ans') || lastMessage.includes('preocup') || lastMessage.includes('nerv') || 
                        lastMessage.includes('anxious') || lastMessage.includes('worried') || lastMessage.includes('nervous')) {
                        return this.i18nManager.translate('suggestions.anxiety') || this.i18nManager.translate('suggestions.default') || [];
                    }
                    
                    if (lastMessage.includes('triste') || lastMessage.includes('depri') || lastMessage.includes('desanim') ||
                        lastMessage.includes('sad') || lastMessage.includes('depressed') || lastMessage.includes('discouraged')) {
                        return this.i18nManager.translate('suggestions.sadness') || this.i18nManager.translate('suggestions.default') || [];
                    }
                    
                    if (lastMessage.includes('sueño') || lastMessage.includes('dormir') || lastMessage.includes('insomnio') ||
                        lastMessage.includes('sleep') || lastMessage.includes('insomnia')) {
                        return this.i18nManager.translate('suggestions.sleep') || this.i18nManager.translate('suggestions.default') || [];
                    }
                    
                    return this.i18nManager.translate('suggestions.default') || [];
                } catch (error) {
                    ErrorHandler.handle(error, 'generating contextual suggestions');
                    return this.i18nManager.translate('suggestions.default') || [];
                }
            }
            
            // Método para actualizar sugerencias rápidas (llamado desde updateUI)
            updateQuickSuggestions() {
                try {
                    this.quickSuggestions = this.generateContextualSuggestions();
                } catch (error) {
                    ErrorHandler.handle(error, 'updating quick suggestions');
                }
            }
        }

        // Inicializar y conectar con la interfaz
        document.addEventListener('DOMContentLoaded', async function() {
            const chatMessages = document.getElementById('chatMessages');
            const userInput = document.getElementById('userInput');
            const sendButton = document.getElementById('sendButton');
            const quickSuggestions = document.getElementById('quickSuggestions');
            const languageSelector = document.getElementById('languageSelector');
            
            const serenBot = new EnhancedSerenBot();
            
            // Esperar a que se inicialice el i18n antes de continuar
            await serenBot.initializeI18n();
            
            // Configurar selector de idioma
            if (languageSelector) {
                languageSelector.addEventListener('change', async (e) => {
                    const newLanguage = e.target.value;
                    const success = await serenBot.changeLanguage(newLanguage);
                    if (success) {
                        // Actualizar mensaje inicial
                        const initialMessage = document.getElementById('initialMessage');
                        if (initialMessage) {
                            initialMessage.textContent = serenBot.i18nManager.translate('greetings.initial_message');
                        }
                        
                        // Actualizar sugerencias
                        updateQuickSuggestions();
                    }
                });
            }
            
            const serenBot = new EnhancedSerenBot();
            
            // Cargar historial de conversación previo si existe
            const savedHistory = StorageManager.load('serenbot_conversation_history');
            if (savedHistory && savedHistory.length > 0) {
                // Mantener solo el mensaje inicial del bot y agregar el historial guardado
                chatMessages.innerHTML = '';
                savedHistory.forEach(msg => {
                    addMessageToChat(msg.message, msg.role === 'user');
                });
            }
            
            // Función para añadir mensaje al chat
            function addMessageToChat(message, isUser = false) {
                const messageElement = document.createElement('div');
                messageElement.className = isUser ? 'message user-message' : 'message bot-message';
                
                const messageText = document.createElement('div');
                messageText.textContent = message;
                
                const messageTime = document.createElement('div');
                messageTime.className = 'message-time';
                messageTime.textContent = 'Ahora';
                
                messageElement.appendChild(messageText);
                messageElement.appendChild(messageTime);
                
                chatMessages.appendChild(messageElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Guardar el historial de la conversación actual
                saveConversationHistory();
            }
            
            // Guardar historial de conversación
            function saveConversationHistory() {
                const messages = Array.from(chatMessages.querySelectorAll('.message')).map(msg => {
                    return {
                        role: msg.classList.contains('user-message') ? 'user' : 'bot',
                        message: msg.querySelector('div:first-child').textContent,
                        timestamp: new Date()
                    };
                });
                
                StorageManager.save('serenbot_conversation_history', messages);
            }
            
            // Función para enviar mensaje
            async function sendMessage() {
                const message = userInput.value.trim();
                if (message) {
                    addMessageToChat(message, true);
                    userInput.value = '';
                    
                    const response = await serenBot.processMessage(message);
                    addMessageToChat(response, false);
                    
                    // Actualizar sugerencias
                    updateQuickSuggestions();
                }
            }
            
            // Función para actualizar sugerencias rápidas
            function updateQuickSuggestions() {
                const suggestions = serenBot.generateContextualSuggestions();
                quickSuggestions.innerHTML = '';
                
                suggestions.forEach(suggestion => {
                    const chip = document.createElement('div');
                    chip.className = 'suggestion-chip';
                    chip.textContent = suggestion;
                    chip.setAttribute('role', 'button');
                    chip.setAttribute('tabindex', '0'); // Make focusable
                    
                    // Set appropriate ARIA label based on current language
                    const suggestionLabel = serenBot.i18nManager.getCurrentLanguage() === 'en' 
                        ? `Suggestion: ${suggestion}` 
                        : `Sugerencia: ${suggestion}`;
                    chip.setAttribute('aria-label', suggestionLabel);
                    
                    // Add keyboard support
                    chip.addEventListener('click', () => {
                        userInput.value = suggestion;
                        sendMessage();
                    });
                    
                    chip.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            userInput.value = suggestion;
                            sendMessage();
                        }
                    });
                    
                    quickSuggestions.appendChild(chip);
                });
            }
            
            // Event listeners
            sendButton.addEventListener('click', sendMessage);
            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            // Inicializar sugerencias
            updateQuickSuggestions();
            
            // Configurar evento para guardar datos antes de cerrar la página
            window.addEventListener('beforeunload', () => {
                serenBot.saveUserData();
                saveConversationHistory();
            });
        });
    </script>
</body>
</html>
